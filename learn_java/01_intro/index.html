<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Introduction to Test-First Training</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.min.css" />
  </head>

  <body class="container">
    <h1>Introduction to Test-First Training</h1>


    <h2>Some Definitions</h2>

    <p>
      <b>Unit Testing</b> refers to writing a set of functions that
      sit next to a given module of program code.  These functions run
      a series of tests that assure, more-or-less thoroughly, that the
      program code performs as it is supposed to.
    </p>

    <p>
      For example, assume there is a function called <tt>add</tt> that
      takes two integers as parameters, adds them together, and
      returns their sum.  There might be one unit test that calls
      <tt>add</tt> with 2 and 3, and makes sure the result is 5.
      There might be additional unit tests that "push the envelope" in
      various other ways, testing its behavior with large numbers,
      negative numbers, illegal parameters (e.g. strings), and so
      forth.
    </p>

    <p>
      Once a full suite of unit tests is developed, it is good
      practice to run these tests as often as possible.
    </p>

    <p>
      <b>Test-First Development</b> (sometimes called <b>Test-Driven
      Development</b> or <b>Test-Driven Design</b>) is the practice of
      writing the unit tests <i>first</i>, before you write a single
      line of implementation code.  While this may seem like putting
      the cart before the horse, there are several good reasons why
      you might want to do this:
    </p>
    <ol>
      <li>
	It forces you to think first about the design of the
	<i>interface</i> to the code, instead of jumping straight to the
	<i>implementation</i>.  Having a well-designed interface is
	often more important than having an efficient implementation.
      </li>
      <li>
	Writing tests is often seen as a chore; writing the tests
	first guarantees that at the end of the day you will have
	written a suite of unit tests (rather than leaving them until
	the end and possibly never getting around to it).
      </li>
      <li>
	If you apply a tight cycle of write one test, then write the
	code to implement that test, then write the next test, your
	code ends up growing organically.  This often (though not
	always) leads to less wasted effort; you end up writing all
	the code you need, and none of the code you don't need.
      </li>
    </ol>

    <p>
      A <b>Unit Testing Framework</b> is a tool or library that
      provides a backdrop for writing unit tests. For example, to
      implement a unit test in the popular

      <A href="http://junit.org">
	JUnit framework,</a>

      you write a class that extends the common TestCase superclass.
      Each method in your subclass that begins with the word "test" is
      a separate unit test.  You then run the JUnit tool (both
      graphical and text versions are provided) and it loads your
      class and executes each test method in turn, monitoring the
      results and providing feedback.
    </p>

    <p>
      <b>Test-First Training</b> follows the example of Test-First
      Development, but with an educational twist.  In Test-First
      Training, the student begins with a single unit test (written by
      the teacher).  In order to implement the test, the student has
      to create source code <i>from scratch</i>.  The student then
      tries to compile and run the test; if the test cannot compile,
      or if the test runs and fails, then the student must go and fix
      his error.  He then moves on to the next test in the lesson.
    </p>

    <h2>Why Test-First Training?</h2>

    <p>
      In traditional programming exercises, you are either given a
      fairly large task and asked to implement the whole thing, or you
      are provided with "skeleton code" -- source code that has been
      eviscerated to remove key sections, which you are asked to fill
      in.
    </p>

    <p>
      "Large task" exercises are often challenging to students because
      of their sheer size.  Many lines of code need to be written
      before the student receives any positive reinforcement that they
      are on the right track.  This can be frustrating to a beginning
      student, and boring to an advanced one.
    </p>

    <p>
      "Skeleton code" exercises are also frustrating.  The task of the
      student should be to figure out how to write code that will
      accomplish the given task.  With skeleton code, they are first
      presented with the task of figuring out what the original author
      was trying to do; of reading through his code (often littered
      with idiosyncratic idioms and obscure comments); and then of
      trying to implement just one part of the algorithm he chose,
      without necessarily understanding the larger picture.  If the
      fill-in-the-blank code section is too complicated, he may never
      complete the assignment; if it's too simple, he may proceed
      without having learned a thing.
    </p>

    <p>
      Finally, in both types of traditional exercises, the student
      doesn't really know when he's finished!  Sometimes, he will
      succeed in the task, but neglect to print his results, and will
      keep at it, believing he's still missing something; other times,
      he will write code that seems to work but is crucially flawed in
      some way or another. This is one of the most powerful features
      of test-first development -- you code until the test passes, and
      then you stop coding.  The test provides a map to the student,
      informing him of where to begin, and where to end.
    </p>

    <p>
      Test-first training is appropriate for both local and remote
      use.  If a student is in a classroom, he may rely on his
      classmates or teachers for guidance; but if he is alone, the
      tests provide some measure of feedback and guidance (although
      unit tests can never actually debug his code).
    </p>

    <p>
      Perhaps the most important aspect of test-first training is that
      it teaches the whole process, from opening a new file in a text
      editor to compiling and running.  At the end of the day, the
      students can say, "At least I know how to write a program."
      Many exercises, especially skeletons but also those based on
      tools and toy problems, end up skipping the fundamentals that
      are vital not just for coding on a day-to-day basis, but also
      for cementing the higher-level concepts into habits and skills.
      (For a Java example, if a student is always provided with a
      skeleton <tt>main()</tt> method, he may end up never memorizing
      the cryptic but essential incantation, "<tt>public static void
      main(String[] args)</tt>").
    </p>

    <h2>How To Use These Exercises</h2>

    <p>
      The exercises are divided into modules.  Each module contains
      several tests.  For each test, you are to write all the code to
      make it run.  Let's walk through this process for a sample
      module.  (Here we assume that you've already installed the Java
      Development Kit, sometimes called JDK or J2SDK, and configured
      it for your system.)
    </p>

    <p>
        Go through the instuctions on one of these pages, then come back here...
        <li>
        <a href="intro-idea.html">Instructions for IntelliJ IDEA</a>
        </li>
        <li>
        <a href="intro-terminal.html">Instructions for the Terminal</a>
        (aka the Command Line or <code>javac</code>).
        </li>
    </p>




    <p>
      Still with me?  Good!  You are now ready to begin.  For each
      module, try to make each test pass, in numerical order.  Each
      module has an index.html page that gives you background on the
      programming tasks, and hints on how to complete individual
      tests.
    </p>

    <p>
        <a class="button" href="../index.html">Java Home</a>
        <a class="button" href="../lessons.html">GO UP TO LESSONS</a>
    </p>


    <hr>

    All contents Copyright (C) 2002-2003 by Alex Chaffee and Purple
    Technology.  All rights reserved.  Please do not distribute
    without permission.  For more information, contact
    alex@purpletech.com.

    <hr>
    <address><a href="mailto:alex@stinky.com">Alex Chaffee</a></address>
<!-- Created: Mon Jul 15 15:21:23 PDT 2002 -->
<!-- hhmts start -->
Last modified: Thu Aug  1 00:30:00 PDT 2002
<!-- hhmts end -->
  </body>
</html>
